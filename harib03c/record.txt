1.将graphic.c，dsctbl.c和bootpack.c中重复的函数声明代码，整合到一起，放在bootpack.h文件中
然后将调用这些函数的文件的开头加上“#include "bootpack.h"”

2.set_segmdesc函数的说明：它是按照CPU的规格要求，将段的信息归结成8个字节写入内存的。为了写入这些信息，使用SEGMENT_DESCRIPTOR结构体。这个结构体中的段基址分为3部分(low两字节+mid一字节+low一字节)，这样设置是为了与8086时代程序兼容。这一次写入的是一个段的信息，有几个段就要写几次，并且他们共同构成段表

3.我对这一部分的段信息的含义（分配位数、为何分配这么多位等问题）掌握的不是很清晰。

4.cpu到底是处于系统模式还是应用模式，取决于位于访问权为0x9a的段，还是0xfa的段。

5.只有LGDT指令可以完成，从指定的内存地址中读取6个字节的内容到GDTR寄存器（48位，低16位存GDT的有效字节数-1，高32位存GDT的开始地址）的功能

6.GDT被设置在0x00270000~0x0027ffff的空间中，没有特殊的意义，只是因为这一部分没有被使用。

7.我们将第一个段空间设置成0xffffffff，地址为0，它表示CPU所能管理的全部内存
  我们见第二个段空间设置成0x0007ffff（512kb），地址为0x280000，这个段是为bootpack.hrb准备的。


9.最终我们实现了简单的分段