鼠标可以移动啦（撒花）
具体操作是：
先隐藏鼠标指针，
然后在鼠标指针的坐标上，加上解读到的位移量
最后因为不能让鼠标指针跑到屏幕外面，所以需要一个判断进行调整。
但是最后画面没有进行叠加处理，因此鼠标会把原有图层给覆盖

为了让鼠标动起来，我们完成了这些工作
总结一下：
1.GDT/IDT/PIC的初始化
2.使用栈和FIFO缓冲区
3.处理键盘中断

最后，解读asmhead.nas文件，对这个文件的作用我的理解还不是很清晰，之后再回来看。
了解到最初状态时，GDT在asmhead.nas里，并不在0x00270000~0x0027ffff范围里。IDT设定都没设定，所以仍处在中断禁止的状态。应当在硬件上积累过多数据产生错误之前，尽快开放中断，接收数据。因此，在bootpack.c的main函数里，应该在调色板初始化以及画面准备之前，先赶紧重新创建GDT和IDT，初始化PIC，并执行“io_sti()”。


TIPS：
virtual和real的区别在于计算内存地址时，是使用段寄存器的值直接指定地址的一部分呢，还是通过GDT使用段寄存器的值指定并非实际存在的地址号码。

本节作者绘出了该系统的内存分布图。