第十五天，挑战多任务
首先，多任务的实现是通过任务间以极短时间定时切换来实现的，定时的时间一般不小于：CPU切换任务本身所消耗的时间的一百倍，这是为了保证效率。

然后，当向CPU发出任务切换指令时，CPU会先把寄存器中的值全部写入内存中，这样做是为了当以后切换回来的时候，可以从中断的地方继续运行。接下来，为了运行下一个程序，CPU会把所有寄存器的值从内存中读取出来（当然这个读取的地址和刚刚写入的地址一定是不同的），这样就相当于完成了一次切换。
（这里我们可以看出，CPU切换任务本身消耗的时间，正是对内存进行写入和读取所消耗的时间。）

再来，TSS（任务状态段）是一个新概念。它是内存段中的一种，需要现在GDT中定义后使用。我们上一步就是向内存中的这个部分写入备份数据。
（需要指出的是，在备份的寄存器中有一个新的寄存器出现了-EIP,即拓展的IP寄存器，它用来记录下一条需要执行的指令位于内存中的哪个地址----题外话，JMP其实就是一个向EIP寄存器赋值的指令，像：JMP 0x1234，CPU会解释为：MOV EIP，0x1234。也就是说这条指令其实是篡改了CPU记忆中下一条该执行的指令的地址。）

如果一条JMP指令所指定的目标地址段不是可执行的代码，而是TSS的话，CPU就不会执行通常的改写EIP和CS操作，而是将这条指令理解为任务切换。也就是说CPU会切换到目标TSS所指定的任务，也就是JMP到一个任务那里去了。（CPU每次执行带有段地址的指令时，都会去确认一下GDT中的设置，以便判断接下来要执行的JMP到底是far-JMP还是任务切换。也就是说从汇编翻译出来的机器语言来看，普通的far-JMP和任务切换的far-JMP，指令本身是没有任何区别的）。

在HariMain文件中中，有几句赋值值得关注：
tss_b.eip = (int) &task_b_main ;
tss_b.esp = task_b_esp ;
我们在bootpack.c中声明了这个task_b_main函数，函数名其实就是一个地址，当调用函数时，跳转到指定的地址执行，这个函数使用的工作栈就是task_b_esp（它的声明和定义在HariMain中: int task_b_esp = memman_alloc_4k(mamman, 64 * 1024) + 64 * 1024;我们为任务B分配了64KB的内存，task_b_esp当前指向栈底地址：push操作esp减，pop操作esp加）
